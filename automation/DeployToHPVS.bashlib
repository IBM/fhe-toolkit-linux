#
# Copyright (C) 2021 IBM. All Rights Reserved.
#
# See the LICENSE file in the root directory
# of this source tree for licensing information.
#

#
# DeployToHPVS.bashlib
# --------------------
#     Subroutines to be used by the DeployToHPVS.sh shell script
# 
# Author(s)
# ---------
#     Lei A.B. Wang <wlwangwl@cn.ibm.com>
#     Dan FitzGerald <danfitz@us.ibm.com>                    
#
# Notes
# -----
#   1. These are a series of BASH script subroutines and will not work on
#      their own.
#
#   2. By default, all commands executed by these functions are silenced
#      except for when a nonzero RC is returned.  To display the commands
#      being executed and their output, issue: `export DEPLOY_TO_HPVS_DEBUG=1`.
#

# Global variable tracking the topmost PID of this script
export SCRIPT_PID=$$

# Global variable containing the current working directory at the time of
# program invocation
CWD_ON_ENTRY=$(pwd)

# Register our script to catch TERM signals and handle them by issuing "exit 1"
trap "exit 1" TERM

#
# Write a "FATAL" message to STDERR and exit with RC=1
#
# Input Parameters:
#   $1 - String message to print
#
# Global Variables Used:
#   registryURL - URL of the Docker registry
#
# Return Values:
#   Successful
#       The message will be printed to STDERR and the program will terminate
#       with RC=1.  The CWD will be set to the value it was on program
#       invocation.
#
#   Error
#       This routine will not fail
#
fatal_error() {
    set +x
    echo -e "FATAL:   $1" 1>&2
    if [[ "$(pwd)" != "$CWD_ON_ENTRY" ]] ; then cd $CWD_ON_ENTRY ; fi
    
    docker_logout
    
    # Issue a TERM signal, which will be caught and terminate the script w\ RC=1
    kill -s TERM $SCRIPT_PID
}

#
# Write a "FATAL" message to STDERR, display program usage information, and
# terminate the program with RC=1
#
# Input Parameters:
#   $1 - String message to print
#
# Global Variables Used:
#   MANPAGE
#
# Return Values:
#   Successful
#       The message will be printed to STDERR and the program will terminate
#       with RC=1.  The CWD will be set to the value it was on program
#       invocation.
#
#   Error
#       This routine will not fail
#
print_fatal_and_usage(){
    set +x
    echo -e "FATAL:   $1" 1>&2
    echo ""
    print_usage "${MANPAGE}"
    if [[ "$(pwd)" != "$CWD_ON_ENTRY" ]] ; then cd $CWD_ON_ENTRY ; fi
    
    # Issue a TERM signal, which will be caught and terminate the script w\ RC=1
    kill -s TERM $SCRIPT_PID
}

#
# Write an "INFO" message to STDOUT
#
# Input Parameters:
#   $1 - String message to print
#
# Global Variables Used:
#   None.
#
# Return Values:
#   Successful
#       RC = 0
#
#   Error
#       This routine will not fail
#
write_info(){
    old_setting=${-//[^x]/}
    set +x
    echo -e "INFO:    $1"
    if [[ -n "$old_setting" ]]; then set -x; else set +x; fi
    return 0
}

#
# Write an "ERROR" message to STDOUT
#
# Input Parameters:
#   $1 - String message to print
#
# Global Variables Used:
#   None.
#
# Return Values:
#   Successful
#       RC = 0
#
#   Error
#       This routine will not fail
#
write_error(){
    old_setting=${-//[^x]/}
    set +x
    echo -e "ERROR:   $1"
    if [[ -n "$old_setting" ]]; then set -x; else set +x; fi
    return 0
}

#
# Write a "SUCCESS" message to STDOUT
#
# Input Parameters:
#   $1 - String message to print
#
# Global Variables Used:
#   None.
#
# Return Values:
#   Successful
#       RC = 0
#
#   Error
#       This routine will not fail
#
write_success(){
    old_setting=${-//[^x]/}
    set +x
    echo -e "SUCCESS: $1"
    if [[ -n "$old_setting" ]]; then set -x; else set +x; fi
    return 0
}

#
# Write a "LOG" message to STDOUT
#
# Input Parameters:
#   $1 - String message to print
#
# Global Variables Used:
#   None.
#
# Return Values:
#   Successful
#       RC = 0
#
#   Error
#       This routine will not fail
#
write_log(){
    old_setting=${-//[^x]/}
    set +x
    echo -e "LOG:     $1"
    if [[ -n "$old_setting" ]]; then set -x; else set +x; fi
    return 0
}

#
# Write a "DEBUG" message to STDOUT
#
# Input Parameters:
#   $1 - String message to print
#
# Global Variables Used:
#   None.
#
# Return Values:
#   Successful
#       RC = 0
#
#   Error
#       This routine will not fail
#
write_debug(){
    old_setting=${-//[^x]/}
    set +x
    echo -e "DEBUG:   $1"
    if [[ -n "$old_setting" ]]; then set -x; else set +x; fi
    return 0
}

#
# Rewrite the value of a configuration variable within a configuration file
#
# Input Parameters:
#   $1 - Path to configuration file
#   $2 - Name of configuration variable
#   $3 - New value of configuration variable
#
# Global Variables Used:
#   None.
#
# Return Values:
#   Successful
#       RC = 0
#
#   Error
#       This routine will not fail
#
change_config_var(){
    
    #echo "${1} ${2} ${3}"
    # Escape forward slashes so they don't foul up sed
    escaped=$(echo "${3}" | sed -e 's/\//\\&/g')
    

    #echo run_command "sed -i '' 's/^"${2}"\=.*$/"${2}"\="${escaped}"/' "${1}
    TYPE=$(uname -s)
    if [[ $TYPE == "Darwin" ]]; then
        run_command "sed -i '' 's/^"${2}"\=.*$/"${2}"\="${escaped}"/' "${1}
    else
        run_command "sed -i 's/^"${2}"\=.*$/"${2}"\="${escaped}"/' "${1}
    fi
    
    if [[ $? != 0 ]]; then
        fatal_error "Error writing to configuration file '${1}'"
    fi
    return 0
}

#
# Prompt for a user response, possibly permitting a default value
#
# Input Parameters:
#   $1 - Prompt text (a terminating colon will be added)
#   $2 - `true` if we are to allow a default value, `false` otherwise
#   $3 - String of default value, if applicable.  If $2 == `true` and no value
#        is passed for $3, then the default value will be the empty string.
#
# Global Variables Used:
#   PROMPT_USER_READARGS
#       Arguments to pass to the `read` command
#   USERINPUT
#
# Return Values:
#   Successful
#       RC = 0
#       Response is in $USERINPUT
#
#   Error
#       A "FATAL" message is written to STDERR, then execution terminates with
#       RC=1.  The CWD will be set to the value it was on program
#       invocation.
#
# Notes:
#   1.  A value of 'default' will be printed as "[default]" in the prompt
#       message, but the value of $USERINPUT will be set to "" on exit.
#
prompt_user(){
    
    # Set the default value string
    if [[ "${2}" == true ]]; then
        local defaultValue=""
        if [[ -n ${3} ]]; then
            defaultValue="${3}"
        fi
    elif [[ "${2}" != false ]]; then
        fatal_error "Internal error: bad function call"
    fi
    
    # Determine the prompt text
    local prompt="${1}:"
    if [[ -n ${defaultValue} ]]; then
        if [[ "$defaultValue" == "" ]]; then
            prompt="${prompt} [<empty string>]"
        else
            prompt="${prompt} [${defaultValue}]"
        fi
    fi

    while [ true ] ; do
        echo "${prompt}"
        read ${PROMPT_USER_READARGS} USERINPUT
        
        # Check for empty string
        if [[ -z "$USERINPUT" ]]; then
            
            # Case 1: We allow for default values
            if [[ -n ${defaultValue} ]]; then
                if [[ "${defaultValue}" == "default" ]]; then
                    defaultValue=""
                fi
                USERINPUT="${defaultValue}"   
                break
            
            # Case 2: We do not allow for default values
            else
                write_error "A value is required"
            fi
        
        # Nonempty string
        else
            break
        fi
    done
    
    return 0
}

#
# Prompt for and verify a filepath
#
# Input Parameters:
#   $1 - Prompt text (a terminating colon will be added)
#   $2 - Boolean; 'true' if user can have an empty response
#
# Global Variables Used:
#   USERINPUT
#
# Return Values:
#   Successful
#       RC = 0
#           Response is in $USERINPUT
#
#   Error
#       This routine will not fail
#
prompt_for_path(){
    local stoploop=false
    local responseRequired=false
    
    if [[ -n ${2} ]] && [[ "${2}" == true ]]; then
        responseRequired=true
    fi

    while [ "$stoploop" == false ] ; do
        echo "${1}:"
        read USERINPUT
        
        # Check for empty string
        if [[ -z "$USERINPUT" ]]; then
            if [[ "$responseRequired" == true ]]; then
                USERINPUT=""
                stoploop=true
            else
                write_error "A value is required"
            fi
        
        # Make sure that this is a valid path
        elif [[ -e "$USERINPUT" ]]; then
            stoploop=true
        
        # Print a message if this is not a valid path
        else
            write_error "No file found at path '${USERINPUT}'"
        fi
    done
    
    return 0
}

#
# Prompt for and verify a passphrase
#
# Input Parameters:
#   $1 - Prompt text (a terminating colon will be added)
#   $2 - Boolean; 'true' if we should ask for password confirmation, 'false'
#        otherwise
#
# Global Variables Used:
#   USERINPUT
#
# Return Values:
#   Successful
#       RC = 0
#       Response is in $USERINPUT
#
#   Error
#       A "FATAL" message is written to STDERR, then execution terminates with
#       RC=1.  The CWD will be set to the value it was on program
#       invocation.
#
prompt_for_passphrase(){
    local confirmPassword=false
    local password1
    local password2
    local counter=0
    
    if [[ -n ${2} ]]; then
        if [[ "${2}" == true ]]; then
            confirmPassword=true
        elif [[ "${2}" == false ]]; then
            confirmPassword=false
        else
            fatal_error "Internal error: bad function call"
        fi
    fi
    
    while [  $counter -lt 3 ]; do
        echo "${1}:"
        read -s password1
        
        # If we are not supposed to be confirming the password, then
        # out of here.  Yes, I'm aware that this is crappy code.
        if [[ "${confirmPassword}" == false ]]; then
            USERINPUT=${password1}
            return 0
        fi
        
        echo "Please confirm:"
        read -s password2
        echo ""
        if [[ "$password1" == "$password2" ]]; then break ; fi
        write_error "Passwords do not match!\n"
        let counter=counter+1 
    done
    if [[ $counter -eq 3 ]]; then
        fatal_error "Too many failed attempts to set passphrase"
    fi
    
    USERINPUT=${password1}
    return 0
}

#
# Generate a configuration file
#
# Input Parameters:
#   $1 - Path to write the new configuration file
#
# Global Variables Used:
#   DEFAULT_CONFIG_FILE
#   DEFAULT_HPVS_NAME
#   DEFAULT_LOCATION
#   DEFAULT_REGISTRATION_FILE
#   DEFAULT_RESOURCE_PLAN_ID
#   DIRNAME
#
# Return Values:
#   Successful
#       RC = 0
#
#   Error
#       A "FATAL" message is written to STDERR, then execution terminates with
#       RC=1.  The CWD will be set to the value it was on program
#       invocation.
#
config_file_wizard(){
    local APIKey
    local cwd=$(pwd)
    local dockerUser
    local gpgVendorKeyName
    local hpvsName
    local usingICR=false
    local whoami=$(whoami)
    
    # Attempt to create the configuration file from our template
    run_command "cp ${DIRNAME}/${DEFAULT_CONFIG_FILE} ${1}"
    if [[ $? != 0 ]]; then
        fatal_error "Unable to create configuration file '${1}'"
    fi
    
    #--------------------------------------------------------------------------#
    # Config variable: APIKey                                                  #
    #--------------------------------------------------------------------------#
    PROMPT_USER_READARGS="-s"
    prompt_user "
===============================================================
Enter an IAM key (platform API key) for your IBM Cloud account. 
An example API key looks like this:

    k-y2lsNxfeKbaidcCG6kQVypLDR_WjmDPe-2Uuq_PTYx

Login to your IBM Cloud account and navigate to Manage > Access (IAM) > API keys for more information." false
    unset PROMPT_USER_READARGS
    APIKey=${USERINPUT}
    change_config_var ${1} "APIKey" "${APIKey}"
    
    #--------------------------------------------------------------------------#
    # Config variable: registryURL                                             #
    #--------------------------------------------------------------------------#
    prompt_user "
===============================================================
Enter URL of container registry. For example, us.icr.io for IBM Cloud Container Registry
For more information about creating a container registry in IBM Cloud see here:

    https://cloud.ibm.com/apidocs/container-registry" false "docker.io"
    registryURL=$(echo "${USERINPUT}" | tr '[:upper:]' '[:lower:]') # Make lowercase
    
    # Strip "http://" or "https://" from string
    registryURL=${registryURL#"https://"}
    registryURL=${registryURL#"http://"}
    
    change_config_var ${1} "registryURL" "${registryURL}"
    
    # If registryURL ends with "*.icr.io", we know that we're using the IBM
    # Cloud Container Registru
    if [[ ${registryURL%%:*} == *.icr.io ]]; then usingICR=true; fi
    
    #--------------------------------------------------------------------------#
    # Config variable: dockerUser and dockerPW                                 #
    #--------------------------------------------------------------------------#
    
    # If using IBM Cloud with the platform API key, the dockerUser is 
    # 'iamapikey' and the dockerPW is your API key. 
    if [[ "$usingICR" == true ]]; then
        dockerUser="iamapikey"
        change_config_var ${1} "dockerUser" "${dockerUser}"
        change_config_var ${1} "dockerPW" "${APIKey}"
    else
        prompt_user "Enter your cloud repository userid" true "${whoami}"
        dockerUser=${USERINPUT}
        change_config_var ${1} "dockerUser" "${dockerUser}"
        
        prompt_for_passphrase "Enter your cloud repository password" false
        change_config_var ${1} "dockerPW" "${USERINPUT}"
    fi
    
    #--------------------------------------------------------------------------#
    # Config variable: namespace                                               #
    #--------------------------------------------------------------------------#
    
    # This code will use the value of dockerUser as the default value if the
    # user just hits ENTER.  For IBM Cloud users, it guesses your system userid
    # as a default.
    if [[ "$usingICR" == true ]]; then
        prompt_user "
===============================================================
Enter target namespace. 
If using IBM Cloud Container Registry, a new namespace must first be created via the web UI, or using the IBM Cloud CLI command: 
    ibmcloud cr namespace-add YOURNAMESPACE." true "${whoami}"
    else
        prompt_user "Enter target namespace. If using DockerHub, you can default to the name of your DockerHub account." true "${dockerUser}"
    fi
   change_config_var ${1} "namespace" "${USERINPUT}"
    
    #--------------------------------------------------------------------------#
    # Config variable: DCTServer                                               #
    #--------------------------------------------------------------------------#
    
    # Strip any port number off the end of registryURL
    registryURL=${registryURL%%:*}
    
    # If the user is using DockerHub, we must keep this field empty.
    #
    # If the user is using IBM Cloud, we already know the value.  Otherwise,
    # use the registryURL as the basis for a good guess.
    USERINPUT=""
    if [[ "$usingICR" == true ]]; then
        USERINPUT="https://${registryURL}:4443"
    elif [[ "${registryURL}" != "docker.io" ]]; then
        prompt_user "Enter the URL of your notary server" true "https://notary.${registryURL}:4443"
    fi
    change_config_var ${1} "DCTServer" "${USERINPUT}"
    
    #--------------------------------------------------------------------------#
    # Config variable: rootPassphrase                                          #
    #--------------------------------------------------------------------------#
    prompt_for_passphrase "
===============================================================
Now we'll need to generate some keys,

1. a Root key which is the root key of the docker content trust to store a tagged image,
2. a repository key (aka target key); allows you to sign image tags and manage delegations (including delegated keys or permitted delegation paths),
3. an Encryption key for the HPVS registration definition file (generated automatically in the background),
4. a Vendor key, required for signing the HPVS registration definition file

Enter passphrase for the root signing key" true
    change_config_var ${1} "rootPassphrase" "${USERINPUT}"
    
    #--------------------------------------------------------------------------#
    # Config variable: repoPassphrase                                          #
    #--------------------------------------------------------------------------#
    prompt_for_passphrase "Enter passphrase for the repository signing key" true
    change_config_var ${1} "repoPassphrase" "${USERINPUT}"
    
    #--------------------------------------------------------------------------#
    # Vendor key configuration                                                 #
    #--------------------------------------------------------------------------#
    write_info "Configuring the vendor key"
    
    while [ true ]; do
        prompt_user "Do you have an existing GPG key that you would like to use? (Y/N)" false
        if [[ -n "$USERINPUT" ]]; then
            USERINPUT=$(echo "$USERINPUT" | tr '[:upper:]' '[:lower:]')
            
            if [[ "$USERINPUT" == "y" ]] || [[ "$USERINPUT" == "yes" ]]; then
                
                # Locate private keyfile
                prompt_for_path "Path to private keyfile"
                change_config_var ${1} "gpgVendorPriFile" "${USERINPUT}"
                        
                # Locate public keyfile
                prompt_for_path "Path to public keyfile"
                change_config_var ${1} "gpgVendorPubFile" "${USERINPUT}"
                
                # Get vendor key name
                prompt_user "Vendor key name" false
                gpgVendorKeyName=${USERINPUT}
                change_config_var ${1} "gpgVendorKeyName" "${USERINPUT}"
                
                # Get vendor key passphrase
                prompt_for_passphrase "Vendor key passphrase" false
                change_config_var ${1} "gpgVendorKeyPassphrase" "${USERINPUT}"
                
                # Leave the loop
                break
                
            elif [[ "$USERINPUT" == "n" ]] || [[ "$USERINPUT" == "no" ]]; then
            
                # Get vendor key name
                prompt_user "Vendor key name" false
                gpgVendorKeyName=${USERINPUT}
                change_config_var ${1} "gpgVendorKeyName" "${gpgVendorKeyName}"
                
                # Get vendor key passphrase
                prompt_for_passphrase "Vendor key passphrase" true
                change_config_var ${1} "gpgVendorKeyPassphrase" "${USERINPUT}"
                
                # Generate the GPG key
                $(echo -e "%echo Generating registration definition key
Key-Type: RSA
Key-Length: 4096
Subkey-Type: RSA
Subkey-Length: 4096
Name-Real: ${gpgVendorKeyName}
Expire-Date: 0
Passphrase: ${USERINPUT}
%echo done" | gpg -a --batch --generate-key )
                if [[ $? != 0 ]]; then
                    fatal_error "Failed to generate new vendor key '${gpgVendorKeyName}'"
                fi
                
                # Export the public part of the key
                run_command "gpg --armor --export ${gpgVendorKeyName} > ${gpgVendorKeyName}.pub"
                if [[ $? != 0 ]]; then
                    fatal_error "Unable to export public key for '${gpgVendorKeyName}'"
                fi
                
                # Locate public key
                change_config_var ${1} "gpgVendorPubFile" "${cwd}/${gpgVendorKeyName}.pub"
                
                # Locate private key
                run_command "gpg --export-secret-keys ${gpgVendorKeyName} > ${gpgVendorKeyName}.key"
                if [[ $? != 0 ]]; then
                    fatal_error "Unable to export private key for '${gpgVendorKeyName}'"
                fi
                change_config_var ${1} "gpgVendorPriFile" "${cwd}/${gpgVendorKeyName}.key"
                
                # Leave the loop
                break
            fi
        fi
    done
    
    #--------------------------------------------------------------------------#
    # Delegation key configuration                                             #
    #--------------------------------------------------------------------------#
    local configure_delegation_key=false
    while [ true ]; do
        prompt_user "Optional: Would you like to configure a delegation key? (Y/N) If not, then the repository key will be used to sign your image. Thereafter, any changes to your image can only be made using the repository key." false
        if [[ -n "$USERINPUT" ]]; then
            USERINPUT=$(echo "$USERINPUT" | tr '[:upper:]' '[:lower:]')
            if [[ "$USERINPUT" == "y" ]] || [[ "$USERINPUT" == "yes" ]]; then
                configure_delegation_key=true
                break
            elif [[ "$USERINPUT" == "n" ]] || [[ "$USERINPUT" == "no" ]]; then
                write_info "No delegation key will be configured"
                break
            fi
        fi
    done
    change_config_var ${1} "delegationkey" "$configure_delegation_key"
    
    if [ "$configure_delegation_key" == true ]; then
        write_info "Configuring the delegation key"
        
        while [ true ]; do
            prompt_user "Do you have an existing key that you would like to use? (Y/N)" false
            if [[ -n "$USERINPUT" ]]; then
                USERINPUT=$(echo "$USERINPUT" | tr '[:upper:]' '[:lower:]')
                if [[ "$USERINPUT" == "y" ]] || [[ "$USERINPUT" == "yes" ]]; then
                    # Prompt for path to private keyfile
                    echo "Leave private keyfile path empty if already in local Docker trust store"
                    prompt_for_path "Path to private keyfile" true
                    change_config_var ${1} "delegationPriFile" "${USERINPUT}"
                    
                    # Prompt for path to public keyfile
                    prompt_for_path "Path to public keyfile" false
                    change_config_var ${1} "delegationPubFile" "${USERINPUT}"
                    
                    # Prompt for delegation key name; cannot be empty
                    prompt_user "Delegation key name" false
                    change_config_var ${1} "delegationkeyName" "${USERINPUT}"
                    
                    # Prompt for delegation key passphrase
                    prompt_for_passphrase "Delegation key passphrase" false
                    change_config_var ${1} "delegationPassphrase" "${USERINPUT}"
                    
                    # Leave the loop
                    break
                    
                elif [[ "$USERINPUT" == "n" ]] || [[ "$USERINPUT" == "no" ]]; then
                
                    # Prompt for delegation key name; cannot be empty
                    prompt_user "Delegation key name" false
                    delegationkeyName=${USERINPUT}
                    change_config_var ${1} "delegationkeyName" "${delegationkeyName}"
                    
                    # Prompt for delegation key passphrase
                    prompt_for_passphrase "Delegation key passphrase" true
                    change_config_var ${1} "delegationPassphrase" "${USERINPUT}"
                    
                    # Generate the delegation key
                    DOCKER_CONTENT_TRUST_REPOSITORY_PASSPHRASE=${USERINPUT} docker trust key generate ${delegationkeyName}
                    
                    # Locate public key
                    change_config_var ${1} "delegationPubFile" "${cwd}/${delegationkeyName}.pub"
                    
                    # Private key is already in the local Docker trust store
                    change_config_var ${1} "delegationPriFile" ""
                    
                    # Leave the loop
                    break
                fi
            fi
        done
    else 
        # Private key is already in the local Docker trust store
        # We need to clear out the placeholder info so it doesn't try to load it
        change_config_var ${1} "delegationPriFile" ""
    fi
    
    #--------------------------------------------------------------------------#
    # Config variable: registrationFile                                        #
    #--------------------------------------------------------------------------#
    prompt_user "Name of registration file to be created for your new HPVS instance" true "${DEFAULT_REGISTRATION_FILE}"
    change_config_var ${1} "registrationFile" "${USERINPUT}"
    
    #--------------------------------------------------------------------------#
    # Config variable: location                                                #
    #--------------------------------------------------------------------------#
    echo "Possible HPVS instance deployment locations:"
    echo "   dal10 - Dallas, TX, USA"
    echo "   dal12 - Dallas, TX, USA"
    echo "   dal13 - Dallas, TX, USA"
    echo "   fra02 - Frankfurt, HE, DE"
    echo "   fra04 - Frankfurt, HE, DE"
    echo "   fra05 - Frankfurt, HE, DE"
    echo "   syd01 - Sydney, NSW, AU"
    echo "   syd04 - Sydney, NSW, AU"
    echo "   syd05 - Sydney, NSW, AU"
    echo "   wdc04 - Washington, DC, USA"
    echo "   wdc06 - Washington, DC, USA"
    echo "   wdc07 - Washington, DC, USA"
    echo ""
    prompt_user "HPVS deployment location" true "${DEFAULT_LOCATION}"
    change_config_var ${1} "location" "${USERINPUT}"
    
    #--------------------------------------------------------------------------#
    # Config variable: hpvsName                                                #
    #--------------------------------------------------------------------------#
    prompt_user "Name to give your new HPVS instance" true "${DEFAULT_HPVS_NAME}"
    hpvsName=${USERINPUT}
    change_config_var ${1} "hpvsName" "${hpvsName}"
    
    #--------------------------------------------------------------------------#
    # Config variable: resource_group                                          #
    #--------------------------------------------------------------------------#
    prompt_user "ID of IBM Cloud Resource Group to use for your deployment
You can find out more information about resource groups here https://cloud.ibm.com/docs/account?topic=account-rgs. If you are unsure, leave this setting as default" true "default"
    change_config_var ${1} "resource_group" "${USERINPUT}"
    
    #--------------------------------------------------------------------------#
    # Config variable: resource_plan_id                                        #
    #--------------------------------------------------------------------------#
    prompt_user "ID of the IBM Cloud Resource Plan to use for your deployment
For more information on the appropriate id, use the following command: ibmcloud catalog service hpvs. If you are unsure, leave this setting as default" true "default"
    change_config_var ${1} "resource_plan_id" "${USERINPUT}"
    
    write_success "Configuration file '${1}' created"
    
    return 0
}

#
# Read the configuration file
#
# Input Parameters:
#   $1 - Path to the configuration file
#
# Global Variables Used:
#   None.
#
# Return Values:
#   Successful
#       RC = 0
#       The following global variables have been set:
#           APIKey
#           DCTServer
#           delegationkey
#           delegationkeyName
#           delegationPassphrase
#           delegationPriFile
#           delegationPubFile
#           dockerPW
#           dockerUser
#           gpgVendorKeyName
#           gpgVendorKeyPassphrase
#           gpgVendorPriFile
#           gpgVendorPubFile
#           hpvsName
#           namespace
#           registrationFile
#           registryURL
#           repoPassphrase
#           resource_group
#           resource_plan_id
#           rootPassphrase
#
#   Error
#       A "FATAL" message is written to STDERR, then execution terminates with
#       RC=1.  The CWD will be set to the value it was on program
#       invocation.
#
read_config() {
    configFile=$1

    #judge whether config file exists or not.
    if [ ! -f "$configFile" ];then
        fatal_error "No such configuration file: '${configFile}'"
    fi

    #save the old IFS
    OLDIFS=$IFS

    #set the IFS which is used to split the key-value
    IFS="="
    
    echo "READ CONFIG FILE $configFile"
    while read -r key value
    do
    # The docker related configure in the config file can be overwritten
    if [[ "$key"x = "registryURL"x && "$registryURL"x = ""x ]]; then
        registryURL=$value
    elif [[ "$key"x = "namespace"x && "$namespace"x = ""x ]];then
        namespace=$value
    elif [[ "$key"x = "dockerUser"x && "$dockerUser"x = ""x ]];then
        dockerUser=$value
    elif [[ "$key"x = "dockerPW"x && "$dockerPW"x = ""x ]];then
        dockerPW=$value
    elif [[ "$key"x = "DCTServer"x && "$DCTServer"x = ""x ]];then
        DCTServer=$value
    elif [[ "$key"x = "resource_group"x && "$resource_group"x = ""x ]];then
        resource_group=$value
    elif [[ "$key"x = "resource_plan_id"x && "$resource_plan_id"x = ""x ]];then
        resource_plan_id=$value

    # delagation key configure for Docker Content Trust
    elif [[ "$key"x = "delegationkey"x ]];then
        case ${value} in
            true )
                delegationkey=true
                ;;
            false )
                delegationkey=false
                ;;
            *)
                write_error "Invalid value specified for 'delegationkey', ignoring"
                ;;
        esac
    elif [[ "$key"x = "delegationPriFile"x ]];then
        delegationPriFile=$value
    elif [[ "$key"x = "delegationPubFile"x ]];then
        delegationPubFile=$value
    elif [[ "$key"x = "delegationkeyName"x ]];then
        delegationkeyName=$value
    elif [[ "$key"x = "delegationPassphrase"x ]];then
        delegationPassphrase=$value
    
    # Root key passphrase and repository key passphrase
    elif [[ "$key"x = "rootPassphrase"x ]];then
        rootPassphrase=$value
    elif [[ "$key"x = "repoPassphrase"x ]];then
        repoPassphrase=$value
    
    # gpg key configure
    elif [[ "$key"x = "gpgVendorPubFile"x ]];then
        gpgVendorPubFile=$value
    elif [[ "$key"x = "gpgVendorPriFile"x ]];then
        gpgVendorPriFile=$value
    elif [[ "$key"x = "gpgVendorKeyName"x ]];then
        gpgVendorKeyName=$value
    elif [[ "$key"x = "gpgVendorKeyPassphrase"x ]];then
        gpgVendorKeyPassphrase=$value
    

    # APIKey
    # HPVS instance registration file, deployment location, name
    elif [[ "$key"x = "APIKey"x ]];then
        APIKey=$value
    elif [[ "$key"x = "registrationFile"x ]];then
        registrationFile=$value
    elif [[ "$key"x = "location"x ]];then
        location=$value
    elif [[ "$key"x = "hpvsName"x ]];then
        hpvsName=$value
    fi

    done < $configFile

    #reset the IFS
    IFS=$OLDIFS
    
    # Get a list of all variables currently set
    for i in _ {a..z} {A..Z}; do
        for var in `eval echo "\\${!$i@}"`; do
            if [[ -n ${all_vars} ]]; then
                all_vars="${all_vars} ${var}"
            else
                all_vars="${var}"
            fi
        done 
    done
    
    required_params=("registryURL" "dockerUser" "dockerPW" "namespace"
                     "rootPassphrase" "repoPassphrase" "gpgVendorPubFile"
                     "gpgVendorPriFile" "gpgVendorKeyName"
                     "gpgVendorKeyPassphrase")
    if [[ "$delegationkey" == true ]]; then
        required_params=(${required_params[@]} "delegationPubFile"
                         "delegationkeyName" "delegationPassphrase")
    fi
    
    # Make sure that all required parameters (at least, those which do not have
    # an automatically-known default value) have been read in
    for i in "${required_params[@]}"; do
        if [ -z "`echo ${all_vars} | xargs -n1 echo | grep -e \"^${i}\$\"`" ]; then
            if [[ -n ${missing_vars} ]]; then
                missing_vars="${missing_vars} ${i}"
            else
                missing_vars="${i}"
            fi
        fi
    done
    if [[ -n ${missing_vars} ]]; then
        fatal_error "Missing one or more required configuration settings: ${missing_vars}"
    fi
    
    unset all_vars
    return 0
}

#
# Write the program usage message to STDOUT
#
# Input Parameters:
#   $1 - Path to manpage file
#
# Global Variables Used:
#   None.
#
# Return Values:
#   Successful
#       RC = 0
#
#   Error
#       This routine will not fail
#
# Notes:
#   1. The program usage message is pulled from the "SYNOPSIS" and "OPTIONS"
#      sections of the program's manpage.  If the usage information needs to
#      change, you must change it there.
#
print_usage(){
    TYPE=$(uname -s)
    if [[ "$TYPE" == "Linux" ]]; then
        # Write the program syntax and option sections from the manpage file
        echo "$(man $1 | sed -n '/^SYNOPSIS/,/^DESCRIPTION/{p;/^DESCRIPTION/q}' | head -n -1)"
        echo ""
        echo "$(man $1 | sed -n '/^OPTIONS/,/^EXAMPLES/{p;/^EXAMPLES/q}' | head -n -1)"
    else
       # Print out the whole man page for mac
       echo "$(man $1)"
    fi
    return 0
}

#
# Silently run a command (except for when DEPLOY_TO_HPVS_DEBUG is set)
#
# Input Parameters:
#   $1 - Command to execute
#
# Global Variables Used:
#   None.
#
# Return Values:
#   Successful
#       RC = 0
#
#   Error
#       RC != 0
#       The return value is that of the failing command.  The failing command
#       output has been logged to the terminal.
#
run_command(){

    # If we are debugging, write the command to STDOUT
    if [[ -n "${DEPLOY_TO_HPVS_DEBUG}" ]]; then
        echo -e "\n--[ DEBUG START ]----------------------------------------"
        echo "COMMAND: $1"
    fi
    
    output=$(eval $1 2>&1)
    rc=$?
    
    if [[ -n "${DEPLOY_TO_HPVS_DEBUG}" ]]; then
        echo "$output"
        echo -e "--[ DEBUG END ]------------------------------------------\n"
    fi
    
    if [[ $rc != 0 ]]; then     
        outstr="Command exited with RC=${rc}"
        
        # To make our logging actually look pretty, indent each line of the
        # program output and print it as one giant log message.  Only do this if
        # we're not printing debugging output.
        if [[ -z "${DEPLOY_TO_HPVS_DEBUG}" ]]; then
            outstr="${outstr}:\n\t   ${output//$'\n'/'\n\t   '}"
        fi
        
        write_log "$outstr"
    fi
    
    return $rc
}

#
# Login to a Docker container registry or cloud backend
#
# Global Variables Used:
#   dockerUser (optional)
#       Name of Docker user to login as.  If unspecified, will prompt for user.
#
#   dockerPW (optional)
#       Password for Docker user.  If unspecified, will prompt for password.
#
# Input Parameters:
#   $1 - URL of the Docker registry
#
# Return Values:
#   Successful
#       RC = 0
#
#   Error
#       A "FATAL" message is written to STDERR, then execution terminates with
#       RC=1.  The CWD will be set to the value it was on program
#       invocation.
#
docker_login(){
    dockerloginCMD="docker login"
    
    if [[ -n $dockerUser ]]; then
        dockerloginCMD="$dockerloginCMD -u $dockerUser"
    fi
    
    if [[ -n $dockerPW ]];then
        dockerloginCMD="echo \"$dockerPW\" | $dockerloginCMD --password-stdin"
    fi
    
    run_command "$dockerloginCMD $1"
    if [[ $? != 0 ]]; then
        fatal_error "Failed to log in to container registry '$1'"
    else
        write_success "Logged in to the container registry at '$1'"
    fi
    
    return 0
}

#
# Log out of a Docker container registry or cloud backend
#
# Global Variables Used:
#   registryURL - URL of the Docker registry
#
# Input Parameters:
#   None
#
# Return Values:
#   Successful
#       RC = 0
#
#   Error
#       This routine will not fail
#
docker_logout(){
    
    # Perform Docker logout
    if [[ -n $registryURL ]]; then
        run_command "docker logout $registryURL"
    else
        run_command "docker logout"
    fi
    
    return 0
}

#
# Load a Docker content trust key
#
# Global Variables Used:
#   None.
#
# Input Parameters:
#   $1 - Passphrase for delegation key
#   $2 - Path to delegation key private file
#   $3 - Name of delegation key
#
# Return Values:
#   Successful
#       RC = 0
#       A new DOCKER_CONTENT_TRUST_REPOSITORY_PASSPHRASE value has been
#       exported, the delegation private key file's permissions have been set to
#       600, and the key has been successfully loaded by docker trust.
#
#   Error
#       A "FATAL" message is written to STDERR, then execution terminates with
#       RC=1.  The CWD will be set to the value it was on program
#       invocation.
#
# Notes:
#   1. For more information about automation with content trust, see:
#           https://docs.docker.com/engine/security/trust/trust_automation/
#
load_trust_key(){

    # Set the private key's permession to 600 if they're not already
    chmod 600 ${2}
    
    # Load the delegation private key using docker trust.
    #
    # The 'docker trust key load' command uses the repositry passphrase, 
    # so set the DOCKER_CONTENT_TRUST_REPOSITORY_PASSPHRASE to that of the
    # delegation private key
    run_command "DOCKER_CONTENT_TRUST_REPOSITORY_PASSPHRASE=${1} docker trust key load ${2} --name ${3}"
    if [[ $? != 0 ]]; then
        fatal_error "Failed to load the delegation private key '${3}'"
    else
        write_success "Loaded the delegation private key '${3}' from private key file '${2}'"
    fi
    
    return 0
}

#
# Initialize a repo for Docker Trust and upload the first key to a delegation
#
# Global Variables Used:
#   None.
#
# Input Parameters:
#   $1 - Root signing certificate passphrase
#   $2 - Repository signing certificate passphrase
#   $3 - Delegation key public file
#   $4 - Delegation key name
#   $5 - Target OCI name
#   $6 - Notary server URL
#
# Return Values:
#   Successful
#     RC = 0
#       The public key has been addded as a signer to the target OCI on the
#       notary server (either indicated by ${6}, or the default DockerHub
#       notary server if ${6} was not specified).
#
#   Error
#       A "FATAL" message is written to STDERR, then execution terminates with
#       RC=1.  The CWD will be set to the value it was on program
#       invocation.
#
# Notes:
#   1. If no Docker Notary server is specified, the default Docker Notary server
#      (https://notary.docker.io) will be assumed
#
#   2. This will add the public key ${3} to the "targets/releases" delegation,
#      and will create a second "targets/${4}" delegation.
#
#   3. Delegations in Docker Content Trust (DCT) allow you to control who can
#      and cannot sign an image tag. A delegation will have a pair of private
#      and public delegation keys. A delegation could contain multiple pairs of
#      keys and contributors in order to a) allow multiple users to be part of a
#      delegation, and b) to support key rotation.  For more information, see:
#           https://docs.docker.com/engine/security/trust/trust_delegation/
#
init_repo_for_notary_server(){
    
    # If a notary server was specified, set DOCKER_CONTENT_TRUST_SERVER
    # accordingly
    if [[ -n ${6} ]]; then
        runcmd="DOCKER_CONTENT_TRUST_SERVER=${6}"
    fi

    # Set the root signing certificate passphrase
    if [[ -n ${runcmd} ]]; then
        runcmd="${runcmd} DOCKER_CONTENT_TRUST_ROOT_PASSPHRASE=${1}"
    else
        runcmd="DOCKER_CONTENT_TRUST_ROOT_PASSPHRASE=${1}"
    fi
    
    # The `docker trust singer add` command requires the repositry passphrase
    runcmd="${runcmd} DOCKER_CONTENT_TRUST_REPOSITORY_PASSPHRASE=${2}"
    
    # Assemble the rest of the run command
    runcmd="${runcmd} docker trust signer add --key ${3} ${4} ${5}"
    
    # Initiate repository in remote notary push delegation key
    run_command "${runcmd}"
    if [[ $? != 0 ]]; then
        fatal_error "Failed to initiate repository '${5}' in notary \nYou will get this message if your cloud plan is over the alloted storage space in the container registry. \nPlease check using 'ibmcloud cr images' command in the cli to verify you are still under your quota."
    else
        write_success "Initiated repository '${5}' in notary, and added '${4}' as a delegation key"
    fi
    
    unset runcmd
    return 0
}

#
# Sign a repository (OCI) in a notary and push it to a container registry
#
# Global Variables Used:
#   None.
#
# Input Parameters:
#   $1 - Root signing certificate passphrase
#   $2 - Delegation key passphrase
#   $3 - Target OCI name
#   $4 - Target OCI tag value
#   $5 - Notary server URL
#
# Return Values:
#   Successful
#       RC = 0
#       The OCI repository has been signed with the delegation key in the
#       notary, and the OCI has been pushed to the container registry.
#
#   Error
#       A "FATAL" message is written to STDERR, then execution terminates with
#       RC=1.  The CWD will be set to the value it was on program
#       invocation.
#
# Notes:
#   1. For more information about automation with content trust, see:
#           https://docs.docker.com/engine/security/trust/trust_automation/
#
sign_and_push_oci(){

    # If a notary server was specified, set DOCKER_CONTENT_TRUST_SERVER
    # accordingly
    if [[ -n ${5} ]]; then
        runcmd="DOCKER_CONTENT_TRUST_SERVER=${5}"
    fi

    # Set the root certificate passphrase
    if [[ -n ${runcmd} ]]; then
        runcmd="${runcmd} DOCKER_CONTENT_TRUST_ROOT_PASSPHRASE=${1}"
    else
        runcmd="DOCKER_CONTENT_TRUST_ROOT_PASSPHRASE=${1}"
    fi

    # Set the delegation key passphrase
    runcmd="${runcmd} DOCKER_CONTENT_TRUST_REPOSITORY_PASSPHRASE=${2}"
    
    # Complete the run command
    runcmd="${runcmd} DOCKER_CONTENT_TRUST=1 docker push ${3}:${4}"
    
    # Sign and push the image
    run_command "${runcmd}"
    if [[ $? != 0 ]]; then
        fatal_error "Failed to sign and push the image '${3}:${4}'"
    else
        write_success "Signed and pushed the image '${3}:${4}'"
    fi
    
    unset runcmd
    return 0
}

#
# Load a GPG public key
#
# Global Variables Used:
#   None.
#
# Input Parameters:
#   $1 - GPG public key name
#   $2 - Path to GPG public keyfile
#
# Return Values:
#   Successful
#       RC = 0
#
#   Error
#       A "FATAL" message is written to STDERR, then execution terminates with
#       RC=1.  The CWD will be set to the value it was on program
#       invocation.
#
gpg_load_public_key(){

    run_command "gpg --import ${2}"
    if [[ $? != 0 ]]; then
    
        # If failure, check whether it has been imported even though RC != 0
        run_command "gpg --list-key ${1}"
        if [[ $? != 0 ]]; then
            fatal_error "Failed to import the public key '${1}' from the key file '${2}'"
        fi
    fi
    
    write_success "Imported the public key '${1}' from the key file '${2}'"
    return 0
}

#
# Load a GPG private key
#
# Global Variables Used:
#   None.
#
# Input Parameters:
#   $1 - Name of GPG private key
#   $2 - Path to GPG private keyfile
#   $3 - Passphrase for GPG private key
#
# Return Values:
#   Successful
#       RC = 0
#
#   Error
#       A "FATAL" message is written to STDERR, then execution terminates with
#       RC=1.  The CWD will be set to the value it was on program
#       invocation.
#
gpg_load_private_key(){
    
    # Check whether the private key is imported or not
    run_command "gpg --list-secret-key ${1}"
    if [[ $? != 0 ]]; then
    
        # If failure, check whether it has been imported even though RC != 0
        run_command "gpg --import --batch --pinentry-mode loopback --passphrase ${3} ${2}"
        if [[ $? != 0 ]]; then
            # The private key may exist, check the output again
            fatal_error "Failed to import the private key '${1}' from the key file '${2}'"
        fi
    fi
    
    write_success "Imported the private key '${1}' from the key file '${2}'"
    return 0
}

#
# Load the (hardcoded) GPG public key needed to encrypt the HPVS registration
# definition file
#
# Global Variables Used:
#   None.
#
# Input Parameters:
#   None
#
# Return Values:
#   Successful
#       String containing the name of the public encryption key for the HPVS
#       registration definition file.
#
#   Error
#       A "FATAL" message is written to STDERR, then execution terminates with
#       RC=1.  The CWD will be set to the value it was on program
#       invocation.
#
gpg_load_public_key_for_regfile_encryption(){
    keyname="rtoa_destination"
    output=$(echo -e '-----BEGIN PGP PUBLIC KEY BLOCK-----

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
mae7WLtydkQnM7Shc1l2CmBCHH8ClSJN
=DsnN
-----END PGP PUBLIC KEY BLOCK-----' | gpg --import 2>&1)
    if [[ $? != 0 ]]; then
    
        # If failure, check whether it has been imported even though RC != 0
        run_command "gpg --list-key ${keyname}"
        if [[ $? != 0 ]]; then
            fatal_error "Failed to import the public key '${keyname}'"
        fi
    fi
    
    echo ${keyname}
}

#
# Encrypt and sign a file
#
# Global Variables Used:
#   None.
#
# Input Parameters:
#   $1 - Path of file to encrypt
#   $2 - User ID on whose behalf we are encrypting the file
#   $3 - User ID that is signing the file
#   $4 - Passphrase to sign the file with
#
# Return Values:
#   Successful
#       RC = 0
#
#   Error
#       A "FATAL" message is written to STDERR, then execution terminates with
#       RC=1.  The CWD will be set to the value it was on program
#       invocation.
#
encrypt_and_sign(){
    
    # Build the gpg command
    gpg_command="gpg --encrypt --sign --local-user ${3} --armor"
    gpg_command="${gpg_command} --recipient ${2} --passphrase ${4}"
    gpg_command="${gpg_command} --trust-model always -o ${1}.asc --yes --batch"
    gpg_command="${gpg_command} --pinentry-mode loopback ${1}"
    
    # Run the gpg command
    run_command "${gpg_command}"
    if [[ $? != 0 ]]; then
        fatal_error "Failed to encrypt and sign '${1}'"
    else
        write_success "Encrypted and signed file '${1}'"
    fi
    
    return 0
}

#
# Call Python BuildRegistrationDefinition to generate the registration json file
#
# Global Variables Used:
#   None.
#
# Input Parameters:
#   $1 - Path to registration definition file
#   $2 - Path to vendor public GPG keyfile
#   $3 - Docker username
#   $4 - Docker password
#   $5 - OCI namespace
#   $6 - OCI repository
#   $7 - Container registry URL
#
# Return Values:
#   Successful
#       RC = 0
#
#   Error
#       A "FATAL" message is written to STDERR, then execution terminates with
#       RC=1.  The CWD will be set to the value it was on program
#       invocation.
#
build_registration_definition_file(){
    working_dir=$(pwd) ; cd $(dirname $1) 
    
    run_command "make init"
    if [[ $? != 0 ]]; then
        fatal_error "Unable to setup the Python environment for BuildRegistrationDefinition"
    fi
    
    # Build the command
    python_command="pipenv run python3 -m BuildRegistrationDefinition"
    python_command="${python_command} --dockerid ${3} --dockerpass ${4} --outputfile ${1}"
    python_command="${python_command} ${7} ${5} ${6} ${2}"
    
    # Run the command
    run_command "${python_command}"
    if [[ $? != 0 ]]; then
        fatal_error "Unable to generate the registration definition file"
    else
        write_success "Created registration definition file '${1}'"
    fi
    
    cd ${working_dir}
    return 0
}

#
# Get an IAM token using an IBM Cloud API key
#
# Global Variables Used:
#   None.
#
# Input Parameters:
#   $1 - API key value for IBM Cloud account
#
# Return Values:
#   Successful
#       String value of the IAM token associated with this IBM Cloud account
#
#   Error
#       A "FATAL" message is written to STDERR, then execution terminates with
#       RC=1.  The CWD will be set to the value it was on program
#       invocation.
#
get_iam_token(){
    response=`curl -sX POST https://iam.cloud.ibm.com/identity/token \
          -H "Content-Type: application/x-www-form-urlencoded" \
          -H "Accept: application/json" \
          -d "grant_type=urn%3Aibm%3Aparams%3Aoauth%3Agrant-type%3Aapikey&apikey=$1"`
    
    # Check errorCode
    ret=$(echo $response | grep "errorCode")
    if [[ "$ret" != "" ]];then
        # Log the error info of the command above
        write_log $response
        fatal_error "Failed to get the IAM Token"
    fi
    
    # Extract IAM Token from response
    jsonCode="import sys, json
print(json.load(sys.stdin)['access_token'])"
    echo $(echo $response | python3 -c "${jsonCode}")
}

#
# Get the IBM Cloud account ID associated with an IAM token
#
# Global Variables Used:
#   None.
#
# Input Parameters:
#   $1 - String value of IAM token
#   $2 - API key value for IBM Cloud account
#
# Return Values:
#   Successful
#       String value of the IBM Cloud account ID associated with this IAM token
#
#   Error
#       A "FATAL" message is written to STDERR, then execution terminates with
#       RC=1.  The CWD will be set to the value it was on program
#       invocation.
#
get_ibm_cloud_id(){
    
    keyDetailsResult=`curl -sX GET https://iam.cloud.ibm.com/v1/apikeys/details \
        -H "Authorization: Bearer $1" \
        -H "IAM-Apikey: $2" \
        -H "Content-Type: application/json"`
    ret=`echo $keyDetailsResult | grep -E "error_code|status_code"`
    if [[ "$ret" != "" ]];then
        # Use echo to print the error info of the command above
        write_log "$keyDetailsResult"
        fatal_error "Unable to determine IBM Cloud account ID"
    fi
    jsonCode="import sys, json
print(json.load(sys.stdin)['account_id'])"
    echo $(echo $keyDetailsResult | python3 -c "${jsonCode}")
}

#
# Get the ID of the default resource group associated with an IBM Cloud account
#
# Global Variables Used:
#   None.
#
# Input Parameters:
#   $1 - String value of the IBM Cloud account ID
#   $2 - String value of the IAM token
#
# Return Values:
#   Successful
#       String value of the default resource group ID associated with the
#       specified IBM Cloud account
#
#   Error
#       A "FATAL" message is written to STDERR, then execution terminates with
#       RC=1.  The CWD will be set to the value it was on program
#       invocation.
#
get_default_resource_group_id(){
    
    # Get a list of all resource groups in the account
    resourceGroups=`curl -sX GET \
        https://resource-controller.cloud.ibm.com/v2/resource_groups?account_id=$1 \
        -H "Authorization: Bearer $2"`
    ret=`echo $resourceGroups | grep -E "error_code|status_code"`
    if [[ "$ret" != "" ]];then
        write_log "$resourceGroups"
        fatal_error "Unable to determine resource groups for account $1"
    fi
    
    # Determine the ID of the default resource group
    jsonCode="import sys, json
for resource in json.load(sys.stdin)['resources']:
    if resource['default'] is True:
        print(resource['id'])
        sys.exit(0)"
    echo $(echo $resourceGroups | python3 -c "${jsonCode}")
}

#
# Provision a new Hyper Protect Virtual Server (HPVS) instance
#
# Global Variables Used:
#   None.
#
# Input Parameters:
#   $1 - Path to registration definition file
#   $2 - Name of the new HPVS instance
#   $3 - IBM Cloud deployment location for new HPVS instance
#   $4 - ID of IBM Cloud resource group to use in deployment
#   $5 - ID of HPVS resource plan to use in deployment
#   $6 - Tag for HPVS image
#
# Return Values:
#   Successful
#       ID of the newly-provisioned HPVS instance
#
#   Error
#       A "FATAL" message is written to STDERR, then execution terminates with
#       RC=1.  The CWD will be set to the value it was on program
#       invocation.
#
provision_hpvs_instance(){
    write_log "PROVISIONING THE INSTANCE"
    registrationDefinition=`sed s/$/"\\\\\n"/ ${1}.asc | tr -d '\n'`
    provisionResult=`curl -sX POST https://resource-controller.cloud.ibm.com/v2/resource_instances \
         -H "Authorization: Bearer $token" -H "Content-Type: application/json"  \
         -d "{  
             \"name\": \"$2\", 
             \"target\": \"$3\",
             \"resource_group\": \"$4\", 
             \"resource_plan_id\": \"$5\",
             \"parameters\":{
                 \"imageTag\":\"$6\",
                 \"registrationDefinition\": \"$registrationDefinition\"}}"`
    
    # Check error_code
    ret=`echo $provisionResult | grep -E "error_code|status_code"`
    if [[ "$ret" != "" ]];then
        error_message=`echo $provisionResult | sed 's/{"message":"\(.*\)",\(.*\)/\1/'`
        if [[ "$error_message" != "" ]];then
            write_log "$error_message"
        fi
        #fatal_error "Failed to provision a Hyper Protect Virtual Server instance"
        return -1
    fi
    
    # Extract the instance id and print log
    jsonCode="import sys, json
print(json.load(sys.stdin)['id'])"
    echo $(echo $provisionResult | python3 -c "${jsonCode}")
}