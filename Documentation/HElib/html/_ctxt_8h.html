<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.18"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>HElib: include/helib/Ctxt.h File Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
		<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:ital,wght@0,100;1,700&family=Merriweather&family=Merriweather+Sans&family=Open+Sans&family=Poppins:ital@1&family=Roboto:ital,wght@0,400;1,300;1,900&display=swap" rel="stylesheet"> 
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
        <link href="jquery.smartmenus.bootstrap.css" rel="stylesheet">
        <script type="text/javascript" src="jquery.smartmenus.js"></script>
        <!-- SmartMenus jQuery Bootstrap Addon -->
        <script type="text/javascript" src="jquery.smartmenus.bootstrap.js"></script>
        <!-- SmartMenus jQuery plugin -->
    </head>
    <body style="font-family: 'Merriweather', serif;">
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">HElib </a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_d0c4ae63660968bf6b1c77a1e8aecf95.html">helib</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Ctxt.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Declarations of a BGV-type ciphertext and key-switching matrices.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;cfloat&gt;</code><br />
<code>#include &lt;<a class="el" href="_double_c_r_t_8h_source.html">helib/DoubleCRT.h</a>&gt;</code><br />
<code>#include &lt;helib/apiAttributes.h&gt;</code><br />
</div>
<p><a href="_ctxt_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_ptxt.html">helib::Ptxt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object that mimics the functionality of the <code><a class="el" href="classhelib_1_1_ctxt.html" title="A Ctxt object holds a single ciphertext.">Ctxt</a></code> object, and acts as a convenient entry point for inputting/encoding data which is to be encrypted.  <a href="classhelib_1_1_ptxt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_s_k_handle.html">helib::SKHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle, describing the secret-key element that "matches" a part, of the form s^r(X^t).  <a href="classhelib_1_1_s_k_handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_ctxt_part.html">helib::CtxtPart</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">One entry in a ciphertext std::vector.  <a href="classhelib_1_1_ctxt_part.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhelib_1_1_ctxt.html">helib::Ctxt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classhelib_1_1_ctxt.html" title="A Ctxt object holds a single ciphertext.">Ctxt</a> object holds a single ciphertext.  <a href="classhelib_1_1_ctxt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:addc58993c7093dd07d98335bab200e82"><td class="memItemLeft" align="right" valign="top"><a id="addc58993c7093dd07d98335bab200e82"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>helib::operator&lt;&lt;</b> (std::ostream &amp;s, const SKHandle &amp;handle)</td></tr>
<tr class="separator:addc58993c7093dd07d98335bab200e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b37f68c4bdc42558ad0360b00984fb"><td class="memItemLeft" align="right" valign="top"><a id="a84b37f68c4bdc42558ad0360b00984fb"></a>
std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>helib::operator&gt;&gt;</b> (std::istream &amp;s, CtxtPart &amp;p)</td></tr>
<tr class="separator:a84b37f68c4bdc42558ad0360b00984fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d941f20d5c3e55e3b36b36dd5164d6b"><td class="memItemLeft" align="right" valign="top"><a id="a2d941f20d5c3e55e3b36b36dd5164d6b"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>helib::operator&lt;&lt;</b> (std::ostream &amp;s, const CtxtPart &amp;p)</td></tr>
<tr class="separator:a2d941f20d5c3e55e3b36b36dd5164d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d9530775923f034eadc4f3e80f355ff"><td class="memItemLeft" align="right" valign="top"><a id="a8d9530775923f034eadc4f3e80f355ff"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>helib::totalProduct</b> (Ctxt &amp;out, const std::vector&lt; Ctxt &gt; &amp;v)</td></tr>
<tr class="separator:a8d9530775923f034eadc4f3e80f355ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693b16168065219388722259c6a02c5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_ctxt_8h.html#a693b16168065219388722259c6a02c5d">helib::incrementalProduct</a> (std::vector&lt; Ctxt &gt; &amp;v)</td></tr>
<tr class="separator:a693b16168065219388722259c6a02c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f851f7c167ee39bfc4ceb06d754dcf0"><td class="memItemLeft" align="right" valign="top"><a id="a8f851f7c167ee39bfc4ceb06d754dcf0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>helib::innerProduct</b> (Ctxt &amp;result, const std::vector&lt; Ctxt &gt; &amp;v1, const std::vector&lt; Ctxt &gt; &amp;v2)</td></tr>
<tr class="separator:a8f851f7c167ee39bfc4ceb06d754dcf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa738424e1ab49c4f39cbcb3e3e920591"><td class="memItemLeft" align="right" valign="top"><a id="aa738424e1ab49c4f39cbcb3e3e920591"></a>
Ctxt&#160;</td><td class="memItemRight" valign="bottom"><b>helib::innerProduct</b> (const std::vector&lt; Ctxt &gt; &amp;v1, const std::vector&lt; Ctxt &gt; &amp;v2)</td></tr>
<tr class="separator:aa738424e1ab49c4f39cbcb3e3e920591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb001c145ac75147f598002b33806849"><td class="memItemLeft" align="right" valign="top"><a id="abb001c145ac75147f598002b33806849"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_ctxt_8h.html#abb001c145ac75147f598002b33806849">helib::innerProduct</a> (Ctxt &amp;result, const std::vector&lt; Ctxt &gt; &amp;v1, const std::vector&lt; DoubleCRT &gt; &amp;v2)</td></tr>
<tr class="memdesc:abb001c145ac75147f598002b33806849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the inner product of a vectors of ciphertexts and a constant vector. <br /></td></tr>
<tr class="separator:abb001c145ac75147f598002b33806849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d0484b1e2d0105b7a2b70a3c6dc182"><td class="memItemLeft" align="right" valign="top"><a id="ad0d0484b1e2d0105b7a2b70a3c6dc182"></a>
Ctxt&#160;</td><td class="memItemRight" valign="bottom"><b>helib::innerProduct</b> (const std::vector&lt; Ctxt &gt; &amp;v1, const std::vector&lt; DoubleCRT &gt; &amp;v2)</td></tr>
<tr class="separator:ad0d0484b1e2d0105b7a2b70a3c6dc182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a60dc124ede5f7baecc0d6c7ab6df6"><td class="memItemLeft" align="right" valign="top"><a id="ab7a60dc124ede5f7baecc0d6c7ab6df6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>helib::innerProduct</b> (Ctxt &amp;result, const std::vector&lt; Ctxt &gt; &amp;v1, const std::vector&lt; NTL::ZZX &gt; &amp;v2)</td></tr>
<tr class="separator:ab7a60dc124ede5f7baecc0d6c7ab6df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d67040ef7ba12958be263a7a93dac9e"><td class="memItemLeft" align="right" valign="top"><a id="a6d67040ef7ba12958be263a7a93dac9e"></a>
Ctxt&#160;</td><td class="memItemRight" valign="bottom"><b>helib::innerProduct</b> (const std::vector&lt; Ctxt &gt; &amp;v1, const std::vector&lt; NTL::ZZX &gt; &amp;v2)</td></tr>
<tr class="separator:a6d67040ef7ba12958be263a7a93dac9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887b96d1f7918079c15b6fa1d8cbfae4"><td class="memItemLeft" align="right" valign="top"><a id="a887b96d1f7918079c15b6fa1d8cbfae4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_ctxt_8h.html#a887b96d1f7918079c15b6fa1d8cbfae4">helib::CheckCtxt</a> (const Ctxt &amp;c, const char *label)</td></tr>
<tr class="memdesc:a887b96d1f7918079c15b6fa1d8cbfae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">print to cerr some info about ciphertext <br /></td></tr>
<tr class="separator:a887b96d1f7918079c15b6fa1d8cbfae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e48196b014916b26112c02883f64e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_ctxt_8h.html#a90e48196b014916b26112c02883f64e3">helib::extractDigits</a> (std::vector&lt; Ctxt &gt; &amp;digits, const Ctxt &amp;c, long r=0)</td></tr>
<tr class="memdesc:a90e48196b014916b26112c02883f64e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the mod-p digits of a mod-p^r ciphertext.  <a href="_ctxt_8h.html#a90e48196b014916b26112c02883f64e3">More...</a><br /></td></tr>
<tr class="separator:a90e48196b014916b26112c02883f64e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab463f07c91389f56b58bb09da140230d"><td class="memItemLeft" align="right" valign="top"><a id="ab463f07c91389f56b58bb09da140230d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>helib::extractDigits</b> (std::vector&lt; Ctxt &gt; &amp;digits, const Ctxt &amp;c, long r, bool shortCut)</td></tr>
<tr class="separator:ab463f07c91389f56b58bb09da140230d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9b160771517accfb43d16c5590942c"><td class="memItemLeft" align="right" valign="top"><a id="a3f9b160771517accfb43d16c5590942c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>helib::extendExtractDigits</b> (std::vector&lt; Ctxt &gt; &amp;digits, const Ctxt &amp;c, long r, long e)</td></tr>
<tr class="separator:a3f9b160771517accfb43d16c5590942c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Declarations of a BGV-type ciphertext and key-switching matrices. </p>
<p>A ciphertext is a std::vector of "ciphertext parts", each part consists of a polynomial (element of polynomial ring R_Q) and a "handle" describing the secret-key polynomial that this part multiplies during decryption. For example:</p><ul>
<li>A "canonical" ciphertext has two parts, the first part multiplies 1 and the second multiplies the "base" secret key s.</li>
<li>When you multiply two canonical ciphertexts you get a 3-part ciphertext, with parts corresponding to 1, s, and s^2.</li>
<li>When you apply automorphism X-&gt;X^t to a generic ciphertext, then<ul>
<li>the part corresponding to 1 still remains wrt 1</li>
<li>every other part corresponding to some s' will now be corresponding to the polynomial s'(X^t) mod Phi_m(X)</li>
</ul>
</li>
</ul>
<p>This type of representation lets you in principle add ciphertexts that are defined with respect to different keys:</p><ul>
<li>For parts of the two ciphertexts that point to the same secret-key polynomial, you just add the two Double-CRT polynomials</li>
<li>Parts in one ciphertext that do not have counter-part in the other ciphertext will just be included in the result intact. For example, you have the ciphertexts C1 = (a relative to 1, b relative to s) C2 = (u relative to 1, v relative to s(X^3)) Then their sum will be C1+C2 = (a+u relative to 1, b relative to s, v relative to s(X^3))</li>
</ul>
<p>Similarly, in principle you can also multiply arbitrary ciphertexts, even ones that are defined with respect to different keys, and the result will be defined with respect to the tensor product of the two keys.</p>
<p>The current implementation is more restrictive, however. It requires that a ciphertext has one part wrt 1, that for every r&gt;=1 there is at most one part wrt to s^r(X^t) (for some t), and that the r's are consecutive. For example you cannot have parts wrt (1,s,s^3) without having a part wrt s^2.</p>
<p>It follows that you can only add/multiply ciphertexts if one of the two lists of handles is a prefix of the other. For example, one can add a ciphertext wrt (1,s(X^2)) to another wrt (1,s(X^2),s^2(X^2)), but not to another ciphertext wrt (1,s). </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a90e48196b014916b26112c02883f64e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90e48196b014916b26112c02883f64e3">&#9670;&nbsp;</a></span>extractDigits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::extractDigits </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>digits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>r</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the mod-p digits of a mod-p^r ciphertext. </p>
<p>extractDigits returns in the slots of digits[j] the j'th-lowest digits from the integers in the slots of the input. Namely, the i'th slot of digits[j] contains the j'th digit in the p-base expansion of the integer in the i'th slot of the *this.</p>
<p>If r==0 then it is set to c.effectiveR(). It is assumed that the slots of *this contains integers mod p^r, i.e., that only the free terms are nonzero. If that assumptions does not hold then the result will not be a valid ciphertext anymore.</p>
<p>The "shortcut" flag is deprecated, it often leads to catastrophic failure in the noise estimate. Calling the function with shortcut=true has not effect, except printing a warning message to cerr.</p>
<p>The output ciphertext digits[j] contains the j'th digit in the base-p expansion of the input, and its plaintext space is modulo p^{r-j}. All the ciphertexts in the output are at the same level. </p>

</div>
</div>
<a id="a693b16168065219388722259c6a02c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a693b16168065219388722259c6a02c5d">&#9670;&nbsp;</a></span>incrementalProduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void helib::incrementalProduct </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classhelib_1_1_ctxt.html">Ctxt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For i=n-1...0, set v[i]=prod_{j&lt;=i} v[j] This implementation uses depth log n and (nlog n)/2 products </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
        <script type="text/javascript" src="doxy-boot.js"></script>
</html>
