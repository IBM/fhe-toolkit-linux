<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.18"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>HElib: /HElib/src/NumbTh.cpp File Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
		<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:ital,wght@0,100;1,700&family=Merriweather&family=Merriweather+Sans&family=Open+Sans&family=Poppins:ital@1&family=Roboto:ital,wght@0,400;1,300;1,900&display=swap" rel="stylesheet"> 
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
        <link href="jquery.smartmenus.bootstrap.css" rel="stylesheet">
        <script type="text/javascript" src="jquery.smartmenus.js"></script>
        <!-- SmartMenus jQuery Bootstrap Addon -->
        <script type="text/javascript" src="jquery.smartmenus.bootstrap.js"></script>
        <!-- SmartMenus jQuery plugin -->
    </head>
    <body style="font-family: 'Merriweather', serif;">
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">HElib Implementing Homomorphic Encryption</a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">NumbTh.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="_numb_th_8h_source.html">helib/NumbTh.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="timing_8h_source.html">helib/timing.h</a>&gt;</code><br />
<code>#include &lt;fstream&gt;</code><br />
<code>#include &lt;cctype&gt;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacehelib"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html">helib</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af6cd0b7c9b7fa0afbb885295f10d9354"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#af6cd0b7c9b7fa0afbb885295f10d9354">helib::bitSetToLong</a> (long bits, long bitSize)</td></tr>
<tr class="memdesc:af6cd0b7c9b7fa0afbb885295f10d9354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Considers <code>bits</code> as a vector of bits and returns the value it represents when interpreted as a n-bit 2's complement number, where n is given by <code>bitSize</code>.  <a href="namespacehelib.html#af6cd0b7c9b7fa0afbb885295f10d9354">More...</a><br /></td></tr>
<tr class="separator:af6cd0b7c9b7fa0afbb885295f10d9354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2638750d81a618d59217f3e9b3218a"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a3f2638750d81a618d59217f3e9b3218a">helib::mcMod</a> (long a, long b)</td></tr>
<tr class="memdesc:a3f2638750d81a618d59217f3e9b3218a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routines for computing mathematically correct mod and div.  <a href="namespacehelib.html#a3f2638750d81a618d59217f3e9b3218a">More...</a><br /></td></tr>
<tr class="separator:a3f2638750d81a618d59217f3e9b3218a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f60e27cb24d575d4b10a522dbb4279"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a51f60e27cb24d575d4b10a522dbb4279">helib::mcDiv</a> (long a, long b)</td></tr>
<tr class="separator:a51f60e27cb24d575d4b10a522dbb4279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96fc760be384a17313e24f5383ceabd1"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a96fc760be384a17313e24f5383ceabd1">helib::multOrd</a> (long p, long m)</td></tr>
<tr class="memdesc:a96fc760be384a17313e24f5383ceabd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return multiplicative order of p modulo m, or 0 if GCD(p, m) != 1.  <a href="namespacehelib.html#a96fc760be384a17313e24f5383ceabd1">More...</a><br /></td></tr>
<tr class="separator:a96fc760be384a17313e24f5383ceabd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9837bdade0e2dabb7bbf0d03a5e2e93b"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a9837bdade0e2dabb7bbf0d03a5e2e93b">helib::computeProd</a> (const NTL::Vec&lt; long &gt; &amp;vec)</td></tr>
<tr class="memdesc:a9837bdade0e2dabb7bbf0d03a5e2e93b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns \prod_d vec[d]  <a href="namespacehelib.html#a9837bdade0e2dabb7bbf0d03a5e2e93b">More...</a><br /></td></tr>
<tr class="separator:a9837bdade0e2dabb7bbf0d03a5e2e93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aababf76c7325db9e7409cf950a581993"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aababf76c7325db9e7409cf950a581993">helib::computeProd</a> (const std::vector&lt; long &gt; &amp;vec)</td></tr>
<tr class="separator:aababf76c7325db9e7409cf950a581993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad7e0c1723b324e29278f21aa889143"><td class="memItemLeft" align="right" valign="top">NTL::ZZX&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#adad7e0c1723b324e29278f21aa889143">helib::makeIrredPoly</a> (long p, long d)</td></tr>
<tr class="memdesc:adad7e0c1723b324e29278f21aa889143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a degree-d irreducible polynomial mod p.  <a href="namespacehelib.html#adad7e0c1723b324e29278f21aa889143">More...</a><br /></td></tr>
<tr class="separator:adad7e0c1723b324e29278f21aa889143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d163aa9f73ad476ebd97d7778d79258"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a8d163aa9f73ad476ebd97d7778d79258">helib::factorize</a> (std::vector&lt; long &gt; &amp;factors, long N)</td></tr>
<tr class="memdesc:a8d163aa9f73ad476ebd97d7778d79258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factoring by trial division, only works for N&lt;2^{60}, only the primes are recorded, not their multiplicity.  <a href="namespacehelib.html#a8d163aa9f73ad476ebd97d7778d79258">More...</a><br /></td></tr>
<tr class="separator:a8d163aa9f73ad476ebd97d7778d79258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a26515bfdcb0f7e654cefa0d955d4be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a0a26515bfdcb0f7e654cefa0d955d4be">helib::factorize</a> (std::vector&lt; NTL::ZZ &gt; &amp;factors, const NTL::ZZ &amp;N)</td></tr>
<tr class="separator:a0a26515bfdcb0f7e654cefa0d955d4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75dc52f12b0306195238f56bcf4a112b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a75dc52f12b0306195238f56bcf4a112b">helib::factorize</a> (NTL::Vec&lt; NTL::Pair&lt; long, long &gt;&gt; &amp;factors, long N)</td></tr>
<tr class="memdesc:a75dc52f12b0306195238f56bcf4a112b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factoring by trial division, only works for N&lt;2^{60} primes and multiplicities are recorded.  <a href="namespacehelib.html#a75dc52f12b0306195238f56bcf4a112b">More...</a><br /></td></tr>
<tr class="separator:a75dc52f12b0306195238f56bcf4a112b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407ad6533d4dd3820cc35b07ad41988b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a407ad6533d4dd3820cc35b07ad41988b">helib::pp_factorize</a> (std::vector&lt; long &gt; &amp;factors, long N)</td></tr>
<tr class="memdesc:a407ad6533d4dd3820cc35b07ad41988b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prime-power factorization.  <a href="namespacehelib.html#a407ad6533d4dd3820cc35b07ad41988b">More...</a><br /></td></tr>
<tr class="separator:a407ad6533d4dd3820cc35b07ad41988b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add32ec15c61473a42b7136dee8360b8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#add32ec15c61473a42b7136dee8360b8b">helib::phiN</a> (long &amp;phiN, std::vector&lt; long &gt; &amp;facts, long N)</td></tr>
<tr class="memdesc:add32ec15c61473a42b7136dee8360b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Phi(N) and also factorize N.  <a href="namespacehelib.html#add32ec15c61473a42b7136dee8360b8b">More...</a><br /></td></tr>
<tr class="separator:add32ec15c61473a42b7136dee8360b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62dc0ba06446370515708c0229fa046e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a62dc0ba06446370515708c0229fa046e">helib::phiN</a> (NTL::ZZ &amp;phiN, std::vector&lt; NTL::ZZ &gt; &amp;facts, const NTL::ZZ &amp;N)</td></tr>
<tr class="separator:a62dc0ba06446370515708c0229fa046e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e575c4502d7606d86b46af66600ce0"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a93e575c4502d7606d86b46af66600ce0">helib::phi_N</a> (long N)</td></tr>
<tr class="memdesc:a93e575c4502d7606d86b46af66600ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Phi(N).  <a href="namespacehelib.html#a93e575c4502d7606d86b46af66600ce0">More...</a><br /></td></tr>
<tr class="separator:a93e575c4502d7606d86b46af66600ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f0037687252f6999a8526165cd8e41"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a67f0037687252f6999a8526165cd8e41">helib::findGenerators</a> (std::vector&lt; long &gt; &amp;gens, std::vector&lt; long &gt; &amp;ords, long m, long p, const std::vector&lt; long &gt; &amp;candidates=std::vector&lt; long &gt;())</td></tr>
<tr class="separator:a67f0037687252f6999a8526165cd8e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcf094f13d09fba535a0ac173449843f"><td class="memTemplParams" colspan="2">template&lt;typename zp , typename zz &gt; </td></tr>
<tr class="memitem:adcf094f13d09fba535a0ac173449843f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#adcf094f13d09fba535a0ac173449843f">helib::FindPrimRootT</a> (zp &amp;root, unsigned long e)</td></tr>
<tr class="separator:adcf094f13d09fba535a0ac173449843f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1f9936cf8c582202702cbb65eaf2ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a9e1f9936cf8c582202702cbb65eaf2ce">helib::FindPrimitiveRoot</a> (NTL::zz_p &amp;r, unsigned long e)</td></tr>
<tr class="memdesc:a9e1f9936cf8c582202702cbb65eaf2ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find e-th root of unity modulo the current modulus.  <a href="namespacehelib.html#a9e1f9936cf8c582202702cbb65eaf2ce">More...</a><br /></td></tr>
<tr class="separator:a9e1f9936cf8c582202702cbb65eaf2ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ed622332f1680e6384644d3c347e19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ae3ed622332f1680e6384644d3c347e19">helib::FindPrimitiveRoot</a> (NTL::ZZ_p &amp;r, unsigned long e)</td></tr>
<tr class="separator:ae3ed622332f1680e6384644d3c347e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d98c1a6634ea3827fafd456ea56a5e"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ad4d98c1a6634ea3827fafd456ea56a5e">helib::mobius</a> (long n)</td></tr>
<tr class="memdesc:ad4d98c1a6634ea3827fafd456ea56a5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute mobius function (naive method as n is small).  <a href="namespacehelib.html#ad4d98c1a6634ea3827fafd456ea56a5e">More...</a><br /></td></tr>
<tr class="separator:ad4d98c1a6634ea3827fafd456ea56a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181a74dc451ffc410450d6c238f2a68c"><td class="memItemLeft" align="right" valign="top">NTL::ZZX&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a181a74dc451ffc410450d6c238f2a68c">helib::Cyclotomic</a> (long N)</td></tr>
<tr class="memdesc:a181a74dc451ffc410450d6c238f2a68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute cyclotomic polynomial.  <a href="namespacehelib.html#a181a74dc451ffc410450d6c238f2a68c">More...</a><br /></td></tr>
<tr class="separator:a181a74dc451ffc410450d6c238f2a68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b5c3e6a25c84bcec39b646e10598378"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a9b5c3e6a25c84bcec39b646e10598378">helib::primroot</a> (long N, long phiN)</td></tr>
<tr class="memdesc:a9b5c3e6a25c84bcec39b646e10598378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a primitive root modulo N.  <a href="namespacehelib.html#a9b5c3e6a25c84bcec39b646e10598378">More...</a><br /></td></tr>
<tr class="separator:a9b5c3e6a25c84bcec39b646e10598378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8693a4a2d91babebc9b8887bbcd1f0ea"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a8693a4a2d91babebc9b8887bbcd1f0ea">helib::ord</a> (long N, long p)</td></tr>
<tr class="memdesc:a8693a4a2d91babebc9b8887bbcd1f0ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the highest power of p that divides N.  <a href="namespacehelib.html#a8693a4a2d91babebc9b8887bbcd1f0ea">More...</a><br /></td></tr>
<tr class="separator:a8693a4a2d91babebc9b8887bbcd1f0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0bcd83ef1650a094f9ba12551a2e9e4"><td class="memItemLeft" align="right" valign="top">NTL::ZZX&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ad0bcd83ef1650a094f9ba12551a2e9e4">helib::RandPoly</a> (long n, const NTL::ZZ &amp;p)</td></tr>
<tr class="separator:ad0bcd83ef1650a094f9ba12551a2e9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc507c5ea1850c348a7c2d743b59a57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a8fc507c5ea1850c348a7c2d743b59a57">helib::MulMod</a> (NTL::ZZX &amp;out, const NTL::ZZX &amp;f, long a, long q, bool abs)</td></tr>
<tr class="separator:a8fc507c5ea1850c348a7c2d743b59a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e504f2374c5e7357c7608a94527887"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a00e504f2374c5e7357c7608a94527887">helib::balanced_MulMod</a> (NTL::ZZX &amp;out, const NTL::ZZX &amp;f, long a, long q)</td></tr>
<tr class="separator:a00e504f2374c5e7357c7608a94527887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1249c9ddf12d285f6c06985342e52562"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a1249c9ddf12d285f6c06985342e52562">helib::is_in</a> (long x, int *X, long sz)</td></tr>
<tr class="memdesc:a1249c9ddf12d285f6c06985342e52562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds whether x is an element of the set X of size sz, Returns -1 it not and the location if true.  <a href="namespacehelib.html#a1249c9ddf12d285f6c06985342e52562">More...</a><br /></td></tr>
<tr class="separator:a1249c9ddf12d285f6c06985342e52562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5165f6a4ea9a752c8c40d5790acfb4e0"><td class="memTemplParams" colspan="2">template&lt;class zzvec &gt; </td></tr>
<tr class="memitem:a5165f6a4ea9a752c8c40d5790acfb4e0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a5165f6a4ea9a752c8c40d5790acfb4e0">helib::intVecCRT</a> (NTL::vec_ZZ &amp;vp, const NTL::ZZ &amp;p, const zzvec &amp;vq, long q)</td></tr>
<tr class="memdesc:a5165f6a4ea9a752c8c40d5790acfb4e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Incremental integer CRT for vectors.  <a href="namespacehelib.html#a5165f6a4ea9a752c8c40d5790acfb4e0">More...</a><br /></td></tr>
<tr class="separator:a5165f6a4ea9a752c8c40d5790acfb4e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dae2334b1ae6358865ee8fd0c6a8fc6"><td class="memItemLeft" align="right" valign="top">template bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a0dae2334b1ae6358865ee8fd0c6a8fc6">helib::intVecCRT</a> (NTL::vec_ZZ &amp;, const NTL::ZZ &amp;, const NTL::vec_ZZ &amp;, long)</td></tr>
<tr class="separator:a0dae2334b1ae6358865ee8fd0c6a8fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3781935233076f4d0110d4c7a358ccf"><td class="memItemLeft" align="right" valign="top">template bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ae3781935233076f4d0110d4c7a358ccf">helib::intVecCRT</a> (NTL::vec_ZZ &amp;, const NTL::ZZ &amp;, const NTL::vec_long &amp;, long)</td></tr>
<tr class="separator:ae3781935233076f4d0110d4c7a358ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c41ad906b8626fb07781c8927102b4f"><td class="memItemLeft" align="right" valign="top">template bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a2c41ad906b8626fb07781c8927102b4f">helib::intVecCRT</a> (NTL::vec_ZZ &amp;, const NTL::ZZ &amp;, const NTL::Vec&lt; NTL::zz_p &gt; &amp;, long)</td></tr>
<tr class="separator:a2c41ad906b8626fb07781c8927102b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d7a435e482d03e39e3b592765adc85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ad7d7a435e482d03e39e3b592765adc85">helib::ModComp</a> (NTL::ZZX &amp;res, const NTL::ZZX &amp;g, const NTL::ZZX &amp;h, const NTL::ZZX &amp;f)</td></tr>
<tr class="memdesc:ad7d7a435e482d03e39e3b592765adc85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modular composition of polynomials: res = g(h) mod f.  <a href="namespacehelib.html#ad7d7a435e482d03e39e3b592765adc85">More...</a><br /></td></tr>
<tr class="separator:ad7d7a435e482d03e39e3b592765adc85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11db92e970f97ed66aebb1702dc5a0df"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a11db92e970f97ed66aebb1702dc5a0df">helib::polyEvalMod</a> (const NTL::ZZX &amp;poly, long x, long p)</td></tr>
<tr class="memdesc:a11db92e970f97ed66aebb1702dc5a0df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a modular integer polynomial, returns poly(x) mod p.  <a href="namespacehelib.html#a11db92e970f97ed66aebb1702dc5a0df">More...</a><br /></td></tr>
<tr class="separator:a11db92e970f97ed66aebb1702dc5a0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7d6d68a0351702ae31c17eb4e72307"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a9e7d6d68a0351702ae31c17eb4e72307">helib::interpolateMod</a> (NTL::ZZX &amp;poly, const NTL::vec_long &amp;x, const NTL::vec_long &amp;y, long p, long e=1)</td></tr>
<tr class="memdesc:a9e7d6d68a0351702ae31c17eb4e72307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate polynomial such that poly(x[i] mod p)=y[i] (mod p^e) It is assumed that the points x[i] are all distinct modulo p.  <a href="namespacehelib.html#a9e7d6d68a0351702ae31c17eb4e72307">More...</a><br /></td></tr>
<tr class="separator:a9e7d6d68a0351702ae31c17eb4e72307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df3789de0744e7c90d5a5d6cf54a5ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a0df3789de0744e7c90d5a5d6cf54a5ed">helib::seekPastChar</a> (std::istream &amp;str, int cc)</td></tr>
<tr class="memdesc:a0df3789de0744e7c90d5a5d6cf54a5ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance the input stream beyond white spaces and a single instance of the char cc.  <a href="namespacehelib.html#a0df3789de0744e7c90d5a5d6cf54a5ed">More...</a><br /></td></tr>
<tr class="separator:a0df3789de0744e7c90d5a5d6cf54a5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db28e5ca105b114e0c89655eee171b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a7db28e5ca105b114e0c89655eee171b9">helib::buildLinPolyMatrix</a> (NTL::mat_zz_pE &amp;M, long p)</td></tr>
<tr class="separator:a7db28e5ca105b114e0c89655eee171b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82218a5a8f14a790b60cd7f288863b9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a82218a5a8f14a790b60cd7f288863b9d">helib::buildLinPolyMatrix</a> (NTL::mat_GF2E &amp;M, long p)</td></tr>
<tr class="separator:a82218a5a8f14a790b60cd7f288863b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c25069289464e0a2fb8398199fd5ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a50c25069289464e0a2fb8398199fd5ef">helib::mul</a> (std::vector&lt; NTL::ZZX &gt; &amp;x, const std::vector&lt; NTL::ZZX &gt; &amp;a, long b)</td></tr>
<tr class="separator:a50c25069289464e0a2fb8398199fd5ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9965244b44a7884f3e08999f6adec16f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a9965244b44a7884f3e08999f6adec16f">helib::div</a> (std::vector&lt; NTL::ZZX &gt; &amp;x, const std::vector&lt; NTL::ZZX &gt; &amp;a, long b)</td></tr>
<tr class="separator:a9965244b44a7884f3e08999f6adec16f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33424cc1805af9dc818e142033c9d9be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a33424cc1805af9dc818e142033c9d9be">helib::add</a> (std::vector&lt; NTL::ZZX &gt; &amp;x, const std::vector&lt; NTL::ZZX &gt; &amp;a, const std::vector&lt; NTL::ZZX &gt; &amp;b)</td></tr>
<tr class="separator:a33424cc1805af9dc818e142033c9d9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb8f2124f5f56970fe7f88802c976b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#acdb8f2124f5f56970fe7f88802c976b1">helib::ppsolve</a> (NTL::vec_zz_pE &amp;x, const NTL::mat_zz_pE &amp;A, const NTL::vec_zz_pE &amp;b, long p, long r)</td></tr>
<tr class="memdesc:acdb8f2124f5f56970fe7f88802c976b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prime power solver.  <a href="namespacehelib.html#acdb8f2124f5f56970fe7f88802c976b1">More...</a><br /></td></tr>
<tr class="separator:acdb8f2124f5f56970fe7f88802c976b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0faaee69d7f687471cb483dfa78e6701"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a0faaee69d7f687471cb483dfa78e6701">helib::ppsolve</a> (NTL::vec_GF2E &amp;x, const NTL::mat_GF2E &amp;A, const NTL::vec_GF2E &amp;b, long p, long r)</td></tr>
<tr class="memdesc:a0faaee69d7f687471cb483dfa78e6701"><td class="mdescLeft">&#160;</td><td class="mdescRight">A version for GF2: must have p == 2 and r == 1.  <a href="namespacehelib.html#a0faaee69d7f687471cb483dfa78e6701">More...</a><br /></td></tr>
<tr class="separator:a0faaee69d7f687471cb483dfa78e6701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a34ea89aec17e40d20d534e210a14f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a73a34ea89aec17e40d20d534e210a14f">helib::ppInvert</a> (NTL::mat_zz_pE &amp;X, const NTL::mat_zz_pE &amp;A, long p, long r)</td></tr>
<tr class="separator:a73a34ea89aec17e40d20d534e210a14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784e87216f278000cfa935b61657da58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a784e87216f278000cfa935b61657da58">helib::ppInvert</a> (NTL::mat_zz_p &amp;X, const NTL::mat_zz_p &amp;A, long p, long r)</td></tr>
<tr class="memdesc:a784e87216f278000cfa935b61657da58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the inverse mod p^r of an n x n matrix.  <a href="namespacehelib.html#a784e87216f278000cfa935b61657da58">More...</a><br /></td></tr>
<tr class="separator:a784e87216f278000cfa935b61657da58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5711dacd10c102835bd585bff52e32c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a5711dacd10c102835bd585bff52e32c5">helib::buildLinPolyCoeffs</a> (NTL::vec_zz_pE &amp;C, const NTL::vec_zz_pE &amp;L, long p, long r)</td></tr>
<tr class="memdesc:a5711dacd10c102835bd585bff52e32c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combination of buildLinPolyMatrix and ppsolve.  <a href="namespacehelib.html#a5711dacd10c102835bd585bff52e32c5">More...</a><br /></td></tr>
<tr class="separator:a5711dacd10c102835bd585bff52e32c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae78f42668b74b50bfeec97988619350c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ae78f42668b74b50bfeec97988619350c">helib::buildLinPolyCoeffs</a> (NTL::vec_GF2E &amp;C, const NTL::vec_GF2E &amp;L, long p, long r)</td></tr>
<tr class="memdesc:ae78f42668b74b50bfeec97988619350c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A version for GF2: must be called with p == 2 and r == 1.  <a href="namespacehelib.html#ae78f42668b74b50bfeec97988619350c">More...</a><br /></td></tr>
<tr class="separator:ae78f42668b74b50bfeec97988619350c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dda3f81ff66fb0e9a92bc39ecad0a92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a0dda3f81ff66fb0e9a92bc39ecad0a92">helib::applyLinPoly</a> (NTL::zz_pE &amp;beta, const NTL::vec_zz_pE &amp;C, const NTL::zz_pE &amp;alpha, long p)</td></tr>
<tr class="memdesc:a0dda3f81ff66fb0e9a92bc39ecad0a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a linearized polynomial with coefficient vector C.  <a href="namespacehelib.html#a0dda3f81ff66fb0e9a92bc39ecad0a92">More...</a><br /></td></tr>
<tr class="separator:a0dda3f81ff66fb0e9a92bc39ecad0a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379dfd6585b3c7aab695a9ca33a7ad89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a379dfd6585b3c7aab695a9ca33a7ad89">helib::applyLinPoly</a> (NTL::GF2E &amp;beta, const NTL::vec_GF2E &amp;C, const NTL::GF2E &amp;alpha, long p)</td></tr>
<tr class="memdesc:a379dfd6585b3c7aab695a9ca33a7ad89"><td class="mdescLeft">&#160;</td><td class="mdescRight">A version for GF2: must be called with p == 2 and r == 1.  <a href="namespacehelib.html#a379dfd6585b3c7aab695a9ca33a7ad89">More...</a><br /></td></tr>
<tr class="separator:a379dfd6585b3c7aab695a9ca33a7ad89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f697f7ff3bbb3d9d17f75d35946991"><td class="memItemLeft" align="right" valign="top">std::pair&lt; long, long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a03f697f7ff3bbb3d9d17f75d35946991">helib::rationalApprox</a> (double x, long denomBound=0)</td></tr>
<tr class="separator:a03f697f7ff3bbb3d9d17f75d35946991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564d4348157a8775888f09a680313ba6"><td class="memItemLeft" align="right" valign="top">std::pair&lt; NTL::ZZ, NTL::ZZ &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a564d4348157a8775888f09a680313ba6">helib::rationalApprox</a> (NTL::xdouble x, NTL::xdouble denomBound=NTL::xdouble(0.0))</td></tr>
<tr class="separator:a564d4348157a8775888f09a680313ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b15d5fbf553550437df6ca02d5a282"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#af7b15d5fbf553550437df6ca02d5a282">helib::rem</a> (NTL::zz_pX &amp;r, const NTL::zz_pX &amp;a, const zz_pXModulus1 &amp;ff)</td></tr>
<tr class="separator:af7b15d5fbf553550437df6ca02d5a282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:acd2078641e9787af3d6acbee6d557dad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#acd2078641e9787af3d6acbee6d557dad">helib::PolyRed</a> (NTL::ZZX &amp;out, const NTL::ZZX &amp;in, const NTL::ZZ &amp;q, bool abs=false)</td></tr>
<tr class="separator:acd2078641e9787af3d6acbee6d557dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae977d2527a20cd02ae18841eea99aa2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ae977d2527a20cd02ae18841eea99aa2e">helib::PolyRed</a> (NTL::ZZX &amp;out, const NTL::ZZX &amp;in, long q, bool abs=false)</td></tr>
<tr class="memdesc:ae977d2527a20cd02ae18841eea99aa2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce all the coefficients of a polynomial modulo q.  <a href="namespacehelib.html#ae977d2527a20cd02ae18841eea99aa2e">More...</a><br /></td></tr>
<tr class="separator:ae977d2527a20cd02ae18841eea99aa2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc3d452674c06b19349e1bfc47cd6bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a9bc3d452674c06b19349e1bfc47cd6bb">helib::vecRed</a> (NTL::Vec&lt; NTL::ZZ &gt; &amp;out, const NTL::Vec&lt; NTL::ZZ &gt; &amp;in, long q, bool abs)</td></tr>
<tr class="separator:a9bc3d452674c06b19349e1bfc47cd6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30e7633ce81720d2e73bb8225f82923"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#ae30e7633ce81720d2e73bb8225f82923">helib::vecRed</a> (NTL::Vec&lt; NTL::ZZ &gt; &amp;out, const NTL::Vec&lt; NTL::ZZ &gt; &amp;in, const NTL::ZZ &amp;q, bool abs)</td></tr>
<tr class="separator:ae30e7633ce81720d2e73bb8225f82923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Some enhanced conversion routines</div></td></tr>
<tr class="memitem:afea2ca2bb25fb996d1d3544a353d83eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#afea2ca2bb25fb996d1d3544a353d83eb">helib::convert</a> (NTL::vec_zz_pE &amp;X, const std::vector&lt; NTL::ZZX &gt; &amp;A)</td></tr>
<tr class="separator:afea2ca2bb25fb996d1d3544a353d83eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa20c6011cba88e302d44bb0db4a6e7f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#aa20c6011cba88e302d44bb0db4a6e7f8">helib::convert</a> (NTL::mat_zz_pE &amp;X, const std::vector&lt; std::vector&lt; NTL::ZZX &gt;&gt; &amp;A)</td></tr>
<tr class="separator:aa20c6011cba88e302d44bb0db4a6e7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ec8745473d116541a8b302dfa70fa9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#af1ec8745473d116541a8b302dfa70fa9">helib::convert</a> (std::vector&lt; NTL::ZZX &gt; &amp;X, const NTL::vec_zz_pE &amp;A)</td></tr>
<tr class="separator:af1ec8745473d116541a8b302dfa70fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89daf2e69e1e8c09c09311b1430021f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a89daf2e69e1e8c09c09311b1430021f4">helib::convert</a> (std::vector&lt; std::vector&lt; NTL::ZZX &gt;&gt; &amp;X, const NTL::mat_zz_pE &amp;A)</td></tr>
<tr class="separator:a89daf2e69e1e8c09c09311b1430021f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7508506eab50bf677b80d5dc6669c980"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a7508506eab50bf677b80d5dc6669c980">helib::convert</a> (NTL::Vec&lt; long &gt; &amp;out, const NTL::ZZX &amp;in)</td></tr>
<tr class="separator:a7508506eab50bf677b80d5dc6669c980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb539ffd2cd2268861ad793f88f6393"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a1eb539ffd2cd2268861ad793f88f6393">helib::convert</a> (NTL::Vec&lt; long &gt; &amp;out, const NTL::zz_pX &amp;in, bool symmetric=true)</td></tr>
<tr class="separator:a1eb539ffd2cd2268861ad793f88f6393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a195d039398c66533aa7a1ba455ffcd4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a195d039398c66533aa7a1ba455ffcd4b">helib::convert</a> (NTL::Vec&lt; long &gt; &amp;out, const NTL::GF2X &amp;in)</td></tr>
<tr class="separator:a195d039398c66533aa7a1ba455ffcd4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ddd5fc2763e981326700c9dcc2e777"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#af3ddd5fc2763e981326700c9dcc2e777">helib::convert</a> (NTL::ZZX &amp;out, const NTL::Vec&lt; long &gt; &amp;in)</td></tr>
<tr class="separator:af3ddd5fc2763e981326700c9dcc2e777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b9c95cba9d0a0f6f4a8220548276003"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehelib.html#a4b9c95cba9d0a0f6f4a8220548276003">helib::convert</a> (NTL::GF2X &amp;out, const NTL::Vec&lt; long &gt; &amp;in)</td></tr>
<tr class="separator:a4b9c95cba9d0a0f6f4a8220548276003"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
        <script type="text/javascript" src="doxy-boot.js"></script>
</html>
